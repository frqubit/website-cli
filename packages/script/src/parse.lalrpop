use std::str::FromStr;
use super::apply_string_escapes;
use super::lang::{
    Script, Item,
    Expr, Lit,
    ExprBinary,
    BinOp
};


grammar;

pub Script: Script = {
    Item+ => Script::from(<>)
};

pub Item: Item = {
    "let" <i:Ident> "=" <e:Expr> ";" => Item::new_let(i, e),
    <e:ExprCall> ";" => Item::Expr(e)
}

ExprCall: Expr = {
    <e:Expr> "(" <a:Comma<Expr>> ")" => Expr::new_call(Box::new(e), a)
}

pub Expr: Expr = {
    #[precedence(level="0")]
    Ident => Expr::Ident(<>),
    Lit => Expr::Lit(<>),
    #[precedence(level="2")] #[assoc(side="right")]
    Expr MulDiv Expr => Expr::Binary(ExprBinary::new(<>)),
    #[precedence(level="3")] #[assoc(side="right")]
    Expr AddSub Expr => Expr::Binary(ExprBinary::new(<>)),
    #[precedence(level="4")]
    "(" <e:Expr> ")" => e,
    #[precedence(level="5")] #[assoc(side="right")]
    ExprCall
}

AddSub: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub
}

MulDiv: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div
}

pub Lit: Lit = {
    "true" => Lit::Bool(true),
    "false" => Lit::Bool(false),
    Num => Lit::Int(<>),
    Str => Lit::Str(<>)
}

Ident: String = {
    r"[a-zA-Z][a-zA-Z0-9_]*" => <>.to_string()
};

Num: i64 = {
    r"[0-9]+" => i64::from_str(<>).unwrap()
};

Str: String = <l:r#""(\\\\|\\"|[^"\\])*""#> => apply_string_escapes(&l[1..l.len()-1]).into();

Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
